course website: https://cs.gmu.edu/~offutt/softwaretest/

JUnit testing is a large portion of this class

8/21/18

    three reasons for testing
        1) customers value quality
        2) its cheaper to make a functioning product than to build up a bunch of garbage that will take forever to fix
        3) its a job requirement in today's market agile forces you to do testing

    types of issues
        1) software fault static defect, basically you can't code for shit:
            actual != expected && incorrect internal state && doesn't run
        2) software error, incorrect internal state. your program runs but it doesn't do its job:
            actual output != expected output && incorrect internal state
        3) software failure, external error. basically someone tried to use your software in a way you didn't design it to work:
            actual output != expected output

    a fault is inherently also an error and a failure
    a error is also a failure

    for example if you have a function that is suppose to count the number of 0's in an array
    but you start at index 1 and index 0 has an 0 then it would be a error because your program doesn't do its job
    and it had an incorrect internal state.

    Validation:
        the process of evaluating software at the end of development to ensure compliance with intended usage

    Verification:
        the process of determining whether the products of a given phase of the development process fulfill the requirements established during the previous phase.

    Beizer 5 levels of testing
        0) no difference between testing and debugging: no distinguishing between incorrect behavior and programmatic mistakes. basically you don't think about how the user will view the product
        1) testing is intended to prove correctness. basically this is when you just want to prove your right.
        2) testing is intended to prove that the software is broken. basically the testers point of view, your trying to break everything. makes testers and developers hate each other
        3) team based attempt to minimize risk of deployed code.
        4) testing is a mental state where you are constantly aware of what should be done and how to do things right. testing comes as a natural part of the development because its the best way you know how to develop.

9/4/18

    components of a test case
        RIPR model
            Reach
            Infect
            Propagate
            Reveal
        prefix values, test case values, post-fix values, and expected results necessary for a complete execution + evaluation of the software
        prefix values
            these are inputs needed to get the program into the state to start the test. "navigate to the homepage" type shit
        post-fix values
            these are inputs needed to be entered after the test case values to show the results of the test. "got back an look at the workflow history"
        test case values
            inputs to conduct the test.
        exit values
            values or commands to terminate the program or return it to a working state.
        expected results - test oracle (sounds like a shitty java framework)
            results of the post-fix values produced by this test-case

    test suite / test set
        a group of test cases.
    like 30 minutes on mocking objects and why you might need to do it for a test.
