\documentclass[11pt]{article}
\usepackage{mathtools}
\usepackage{mdframed}
\usepackage{fullpage}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{enumitem}


%edit this for each class
\newcommand\name{John Collin Vincent}
\newcommand\classname{}
\newcommand\assignment{}


\newcounter{excounter}
\setcounter{excounter}{1}
\newcommand\ques[2]{\vskip 1em  \noindent\textbf{\arabic{excounter}\addtocounter{excounter}{1}.} \emph{#1} \noindent#2}
\newenvironment{question}{\ques{}\begin{quote}}{\end{quote}}
\newenvironment{subquestion}[1]{#1) \begin{quote}}{\end{quote}}

\pagestyle{fancy}
\rfoot{\name, page \thepage/\pageref{LastPage}}
\cfoot{}
\rhead{}
\lhead{}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}


\begin{document}


  {\bf \classname \hspace{1cm} \assignment\hfill \name}
  \vskip 2em


  \begin{subquestion}{4.7}
    if there are lots of blocking calls in your program, and there are operations
    that can still be preformed then kernel threads will be helpful. otherwise
    kernel threads add a lot of overhead to your program because a new thread control
    block has to be made and a lot more system calls will have to be made to coordinate
    then, which forces more context switching. User threads make coordination between
    threads a lot safer, while kernel threads need to be managed a lot closer. Since
    its a single processor system multiple kernel threads will still have to be executed by
    the same processor, just like the user threads. Kernel threads are more beneficial in
    environments with multiple CPU's since the different kernel threads can operate
    on different processors while the Users threads cannot.
  \end{subquestion}

  \begin{subquestion}{4.8}
    Heap memory is always shared, and in most platforms global variables are shared.
    stack and register values are different.
  \end{subquestion}

  \begin{subquestion}{4.11}
    yes it is, concurrency is just when different task, have overlapping
    run times, where parallelism is when one task runs different sub task
    at the same time to more quickly finish the one main task. so you could
    have multiple unrelated processes running within the same time period
    but not actually being computed at the same time, like a context switch while one
    one processes is waiting for an Io operation, then a context switch back.
    in this example the two processes didn't run in parallel but they did run concurrently.
  \end{subquestion}

  \begin{subquestion}{4.17}

  \end{subquestion}

  \begin{subquestion}{4.18}
    \begin{enumerate}[label=(\alph*)]
      \item each thread will execute on a different core. This will have good preformance
      since minimal context switches will be needed.
      \item threads will take turns executing on the different cores as they become available.
      this will have the worst preformance since lots of context switches will be incured.
      \item each kernel thread will execute on one core, and they will execute different
      user threads as they are available to. this will have ideal performance for a program
      that needs more threads than there are cores, since the context switches will
      be minimal and the users threads will be managed more efficiently than actual Kernel
      threads
    \end{enumerate}
  \end{subquestion}

\end{document}
