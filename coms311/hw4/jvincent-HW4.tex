\documentclass[11pt]{article}
\usepackage{mathtools}
\usepackage{mdframed}
\usepackage{fullpage}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\lstdefinelanguage{JavaScript}{
  keywords={break, case, catch, continue, debugger, default, delete, do, else, false, finally, for, function, if, in, instanceof, new, null, return, switch, this, throw, true, try, typeof, var, void, while, with},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  ndkeywords={class, export, boolean, throw, implements, import, this},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  sensitive=true
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}


%edit this for each class
\newcommand\name{John Collin Vincent}
\newcommand\classname{Com S 311}
\newcommand\assignment{Homework 4}


\newcounter{excounter}
\setcounter{excounter}{1}
\newcommand\ques[2]{\vskip 1em  \noindent\textbf{\arabic{excounter}\addtocounter{excounter}{1}.} \emph{#1} \noindent#2}
\newenvironment{question}{\ques{}\begin{quote}}{\end{quote}}


\pagestyle{fancy}
\rfoot{\name, page \thepage/\pageref{LastPage}}
\cfoot{}
\rhead{}
\lhead{}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\newcommand\tab{\null\hspace{.4cm}}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}


\begin{document}


  {\bf \classname \hspace{1cm} \assignment\hfill \name}
  \vskip 2em


  \begin{question}
    a)\\
    \begin{center}
      \begin{tikzpicture}[level/.style={sibling distance=60mm/#1}]
        \node [circle,draw] (a){$59$}
          child {node [circle,draw] (b) {$12$}
            child {node [circle,draw] (c) {$9$}
              child {node [circle,draw] (d) {$2$}}
              child{node [circle,draw] (i) {$8$}}
            }
            child {node [circle,draw] (e) {$10$}}
          }
          child{node [circle,draw] (f) {$52$}
            child{node [circle,draw] (g) {$5$}}
            child{node [circle,draw] (h) {$13$}}
          };
      \end{tikzpicture}
    \end{center}
    b)
    \begin{quote}
      you would remove 59 and replace it with 8 then heapify down until 8 settles into a spot.
    \end{quote}
    \begin{center}
      \begin{tikzpicture}[level/.style={sibling distance=60mm/#1}]
        \node [circle,draw] (a){$52$}
          child {node [circle,draw] (b) {$12$}
            child {node [circle,draw] (c) {$9$}
              child {node [circle,draw] (d) {$2$}}
            }
            child {node [circle,draw] (e) {$10$}}
          }
          child{node [circle,draw] (f) {$13$}
            child{node [circle,draw] (g) {$5$}}
            child{node [circle,draw] (h) {$8$}}
          };
      \end{tikzpicture}
    \end{center}
  \end{question}

  \begin{question}
  \end{question}

  \begin{question}
    a)
    \begin{quote}
      \[ 2(n-2) + 1 = 2n-3 \]
    \end{quote}
    \clearpage
    b)
    \begin{lstlisting}[language=javascript]
      n1 = null;
      n2 = new Node(A[0]);
      for(var i = 1; i < A.length; i++){
        n1 = new Node(A[i]);
        n1.next = n2;
        n2 = n1;
      }
      n3 = n4 = null;
      newLevel = false;
      //makes a graph of linked nodes in the shape of a pyramid, nodes on a level are linked one direction through the next pointer
      //all nodes that get compared are linked, the larger value gets a clone in the next level with a pointer to it
      // will complete after log_2 n levels are formed with the last level, ends when it starts on a level with only 1 element
      while(!newLevel || n2.next){
        newLevel = false;
        n1 = n2.next;
        if(n1){
          n2.compare = n1;
          n1.compare = n2;
          if(n1.value > n2.value){
            n3 = new Node(n1.value);
            n3.parent = n1
          }else{
            n3 = new Node(n2.value);
            n3.parent = n2;
          }
          n3.next = n4;
          n4 = n3;
          if(n1.next){
            n2 = n1.next;
          }else{
            n4 = null;
            n2 = n3;
            newLevel = true;
          }
        } else{
          newLevel = true;
          n3 = new Node(n2.value);
          n3.parent = n2;
          n3.next = n4;
          n4 = null;
          n2 = n3;
        }
      }
      largest = n2.value
      n2 = n2.parent;
      second = n2.compare.value;
      while(n2.parent){
        n2 = n2.parent;
        if(n2.compare && n2.compare.value > second){
          second = n2.compare.value;
        }
      }
    \end{lstlisting}
    the number of comparisons for the first while loop which finds the largest element is $n-1$, and the number of comparisions to go back down the graph and find the second largest
    is $\log_2 (n-1)$, so the overall number of comparisions is $n-1+\log_2 (n-1)$
  \end{question}

  \begin{question}
    \begin{lstlisting}[language=javascript]
      b = Array(n);
      c = Array(k);
      smallest = null;
      sub = 0;
      for(i = 0; i < k; i++){
        c[i] = 0;
      }
      for(i = 0; i < n; i++){
        smallest = a[c[0]*k];
        sub = 0;
        for(j = 1; j < k; j++){
          if(a[c[j]*k + j] < smallest){
            smallest = a[c[j]*k + j];
            sub = j;
          }
        }
        c[sub]++;
        b[i] = smallest;
      }
    \end{lstlisting}
    This runs in $n*k$ time and it is essentally mimicking the second half of the merge sort algorithm since we start with k sorted sub arrays.
  \end{question}


\end{document}
